<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Pedro Carrasco"/><link rel="canonical" href="https://pedrommcarrasco.github.io/posts/2019-03-24-aerogami_series_part_5"/><meta name="twitter:url" content="https://pedrommcarrasco.github.io/posts/2019-03-24-aerogami_series_part_5"/><meta name="og:url" content="https://pedrommcarrasco.github.io/posts/2019-03-24-aerogami_series_part_5"/><title>Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views | Pedro Carrasco</title><meta name="twitter:title" content="Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views | Pedro Carrasco"/><meta name="og:title" content="Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views | Pedro Carrasco"/><meta name="description" content="iOS Engineer"/><meta name="twitter:description" content="iOS Engineer"/><meta name="og:description" content="iOS Engineer"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Pedro Carrasco"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Pedro Carrasco</a><nav><ul><li><a class="selected" href="/posts">Posts</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><p>When starting to develop any application it's beneficial to think early about the way code can be testable and whether it would be scalable or maintainable. Many iOS applications have suffered from what is called <em>Massive View Controller</em> problem. By putting all the code that fetches, maps, presents and styles into one ViewController it very quickly overgrows in size and complexity. A lot of solutions where introduced to tackle this problem such as MVVM, MVVM + ReactiveCocoa or VIPER. In this application we'll be using <a href="https://clean-swift.com">Clean Swift</a> approach for breaking up massive view controllers into testable and maintainable parts.</p><h1>Data Structures</h1><h2>Data</h2><p><code>Struct</code> containing <em>raw data</em>.</p><pre><code class="language-swift">    struct Data: Equatable {
        let regions: [Region]
        let trips: [Trip]
    }
</code></pre><h2>View Model</h2><p><code>Struct</code> containing <em>State</em> (loading, error, empty, loaded) and mapped data that is used by <em>View Controllers</em> for configuring views.</p><pre><code class="language-swift">    struct ViewModel: FeatureViewModel {
        let state: ViewState&lt;Feed.ViewModel.Content&gt;
        let title: String

        struct Content: FeatureContentViewModel, Equatable {
            var rows: [FeedCardViewModel]
            let availableRegions: [Feed.ViewModel.Content.Region]
            let selectedRegion: Feed.ViewModel.Content.Region?

            struct Region: Equatable {
                let id: String
                let name: String
            }

            var hasContent: Bool {
                return !rows.isEmpty
            }
        }
    }
</code></pre><h2>Action</h2><p><code>Enum</code> with actions that <em>View Controller</em> can do and <em>Interactor</em> can handle.</p><pre><code class="language-swift">    enum Action {
        case load
        case changeRegion(regionId: String?)
    }
</code></pre><h2>Route</h2><p><code>Enum</code> with destinations that <em>View Controller</em> can route to.</p><pre><code class="language-swift">    enum Route: Equatable {
        case book(Trip)
    }
</code></pre><h1>Components</h1><h2>Interactor</h2><p>Receives an action, performs work and sends raw data to presenter.</p><ul><li>Input - <em>Action</em></li><li>Output - <em>Data</em></li><li>Uses - <em>Presenter</em></li></ul><h2>Presenter</h2><p>Receives raw data and maps it into <em>View Model</em></p><ul><li>Input - <em>Data</em></li><li>Output - <em>View Model</em></li></ul><h2>View Controller</h2><p>Receives <em>View Model</em> and configures a view according to it. Sends actions to <em>Interactor</em>.</p><ul><li>Input - <em>View Model</em></li><li>Output - <em>Action</em></li><li>Uses - <em>Interactor</em>, <em>Router</em></li></ul><h2>Router</h2><p>Receives <em>Route</em> object from <em>View Controller</em>, that contains information about next destination, and opens next <em>View Controller</em> using <em>Configurator</em></p><ul><li>Input - <em>Route</em></li><li>Uses - <em>Configurator</em></li></ul><h2>Configurator</h2><p>Takes an input and creates configured <em>View Controller</em> with other components.</p><ul><li>Input - Optional configuration data.</li><li>Output - <em>View Controller</em></li><li>Creates - <em>Interactor</em>, <em>Presenter</em>, <em>View Controller</em>, <em>Router</em></li></ul><h1>Feature</h1><p>The group of these components is called <code>Feature</code>. <a href="https://clean-swift.com">Clean Swift</a> provides with XCode templates that allow to generate all of these components together. We are using <a href="https://github.com/nitesuit/aerogami-ios/tree/master/templates/plop/Feature">plop templates</a> for feature generation. All of this allows to avoid writing boilerplate code and concentrate on actual code of the feature.</p><h1>Feed Example</h1><p><code>Feed</code> is a main <a href="https://github.com/nitesuit/aerogami-ios/tree/master/TravelFeatureKit/Features/Feed">feature</a> of the application. We're going to see how all of these different components is used to create a complete feature.</p><h2>Feed Interactor</h2><p><code>Feed Interactor</code> uses repositories of <em>Region</em>, <em>Trip</em> and <em>Airport</em> for loading data.</p><p><code>dispatch</code> function is an entry point of any <code>Interactor</code>.</p><pre><code class="language-swift">    func dispatch(_ action: Feed.Action) {
        switch action {
        case .load:
            contentState = .loading(data: contentState.data)
            load()
        case .changeRegion(let regionId):
            changeRegion(id: regionId)
        }
    }
</code></pre><p>We can see when <code>FeedInteractor</code> receives <em>load</em> action it sets current state to <em>loading</em> and calls <code>load()</code> method. It combines <code>RegionRepository</code> and <code>TripRepository</code>, maps it to <em>Data</em> object and passes it to <code>FeedPresenter</code> by setting <em>contentState</em>.</p><pre><code class="language-swift">    func load() {
        let selectedRegion = regionRepository.getSelectedRegion()

        Observable.combineLatest(
            self.regionRepository.getRegions(),
            self.tripRepository.getTrips(in: selectedRegion?.id)
            )
            .map { (regions, trips) -&gt; Feed.Data in
                return Feed.Data(
                    regions: regions,
                    trips: trips,
                    selectedRegionId: selectedRegion?.id,
                    tripImages: []
                )
            }
            .subscribe(
                onNext: { data in
                    self.contentState = .loaded(data: data, error: nil)
                    self.loadImages(for: data.trips)
                },
                onError: { error in
                    self.contentState = .error(error: .loading(reason: R.string.localizable.errorGenericTitle()))
                }
            )
            .disposed(by: disposeBag)
    }
</code></pre><h2>Feed Presenter</h2><p><a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelFeatureKit/Features/Feed/FeedPresenter.swift">Feed Presenter</a> essentially takes <code>Feed.Data</code> and returns <code>Feed.ViewModel</code>.</p><pre><code class="language-swift">    func makeContentViewModel(content: Feed.Data) throws -&gt; Feed.ViewModel.Content {
        return Feed.ViewModel.Content(
            rows: makeFeedCardRows(content),
            availableRegions: makeAvailableRegions(content),
            selectedRegion: makeSelectedRegion(content)
        )
    }
</code></pre><p>We can see that <em>struct</em> such as <code>FeedCardViewModel</code> is fairly complicated and comprehensively describes for a table view row what needs to be displayed. It ensures that there is absolutely no business logic, mapping or formatting done in a view as it's simply sets these properties to appropriate variables.</p><pre><code class="language-swift">    private func makeFeedCardRows(_ content: Feed.Data) -&gt; [FeedCardViewModel] {
        return getSortedTrips(content).map { trip in
            currencyFormatter.currencyCode = trip.currency
            return FeedCardViewModel(
                direction: R.string.localizable.feedBothWaysTitle(),
                trip: makeTripString(trip),
                price: formatCurrency(trip),
                dateRange: dateRange(trip),
                routeName: R.string.localizable.feedBookTitle(),
                imageUrl: makeTripImageURL(trip, content: content),
                route: Feed.Route.book(trip),
                isExpired: trip.expiresAt &lt;= Date()
            )
        }
    }
</code></pre><h2>Feed View Controller</h2><p>View Controller in this architecture is a very lean and clean class. It does what view <em>should</em> do: present data, handle user actions and delegate these actions to 'interactor'.</p><p><em>display()</em> lets <code>FeedViewController</code> know that the state and <code>Feed.ViewModel</code> was updated. Different views then can use parts of view model to configure themselves.</p><pre><code class="language-swift">    func display() {
        guard let viewModel = viewModel?.state.viewModel else { return }

        tableView.reloadData()
        headerView.configure(with: viewModel.selectedRegion)
    }
</code></pre><p><code>Feed.Action</code> is sent to <code>Feed.Interactor</code> when anything meaningful happens in <code>FeedViewController.</code> For example, loading data when view appears.</p><pre><code class="language-swift">    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        interactor.subscribe()
        interactor.dispatch(Feed.Action.load)
    }
</code></pre><p><code>Feed.Route</code> is sent to <code>Feed.Router</code> when <code>FeedViewController</code> wants to transition to other view controller.</p><pre><code class="language-swift">    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let cellViewModel = viewModel?.state.viewModel?.rows[indexPath.row] else { return }

        router.route(to: cellViewModel.route)
    }
</code></pre><h2>Feed Router</h2><p><code>FeedRouter</code> handles <em>route</em> actions and opens other view controllers. It uses <code>BookTripConfigurator</code> for building <code>BookTripViewController</code>.</p><pre><code class="language-swift">class FeedRouter {

    private let bookTripConfigurator: BookTripConfigurator

    weak var viewController: FeedViewController?

    init(bookTripConfigurator: BookTripConfigurator) {
        self.bookTripConfigurator = bookTripConfigurator
    }

    func route(to route: Feed.Route) {
        switch route {
        case .book(let trip):
            let bookTripViewController = bookTripConfigurator.createViewController(trip: trip)
            bookTripViewController.modalPresentationStyle = .overCurrentContext
            bookTripViewController.modalTransitionStyle = .coverVertical
            viewController?.tabBarController?.present(bookTripViewController, animated: true, completion: nil)
        }
    }
}
</code></pre><h2>Usage</h2><p>For understanding this flow easier we can imagine a hypothetical scenario of <code>Feed</code> feature.</p><ol><li>AppDelegate uses <code>FeedConfigurator</code> and calls <code>createViewController()</code> to create <code>FeedViewController</code></li><li><code>FeedViewController</code> on <code>viewWillAppear</code> calls <code>interactor.dispatch(Feed.Action.load)</code> to trigger <code>load</code> action</li><li><code>FeedInteractor</code> handles <code>load</code> action and uses <code>TripRepository</code> to load an array of <code>Trips</code> from the backend. It passes an array of <code>Trips</code> to <code>FeedPresenter</code>.</li><li><code>FeedPresenter</code> takes an array of <code>Trips</code> and maps it to <code>FeedViewModel</code> by formatting and localizing text, loading images and splitting it into fields that view needs to know about.</li><li><code>FeedViewController</code>'s method <code>display()</code> is triggered and table view is loaded with new data.</li></ol><p>Although this all may seem too much at first, it actually provides developers with huge clarity when building and maintaining the project. Moreover, all these different components have clear inputs and outputs than can be unit tested. With the growing complexity of the feature it becomes convenient to simply check <code>Action</code> to see all the different things that <code>ViewController</code> does or analyse <code>Presenter</code> to understand what kind of data is actually presented.</p><h2>Result</h2><p>In these series we've seen how to build iOS application by separating it into different frameworks, loading data from API and mapping it using <code>Codable</code>, sketching UIs following Apple's guidelines and develop it all on top of <em>Clean</em> architecture. All of these steps allow the app to be scalable, maintainable and testable.<br><br><img src="/images/aerogami-tutorial/part5/app_demo.gif" alt="App Demo" width="300"/></p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/tutorial">Tutorial</a></li><li><a href="/tags/ios">iOS</a></li><li><a href="/tags/swift">Swift</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>